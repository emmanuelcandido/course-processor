#!/usr/bin/env python3
"""
Curso Processor - Main CLI Interface
A complete course processing system with Nord Theme styling
"""

from config import credentials
import os
import sys
import time
from typing import Optional

import typer
from rich.console import Console
from rich.panel import Panel
from rich.text import Text
from rich.table import Table
from rich.progress import Progress, TextColumn, BarColumn, TaskProgressColumn
from rich.prompt import Prompt, Confirm
from rich.traceback import install

# Import modules
from config import settings
from utils import file_manager, progress_tracker, ui_components

# Install rich traceback handler
install(show_locals=True)

# Initialize typer app
app = typer.Typer(help="Curso Processor - A complete course processing system")

# Initialize rich console with Nord Theme colors
console = Console()

# Nord Theme colors
NORD_WHITE = "bright_white"
NORD_BLUE = "bright_blue"
NORD_CYAN = "bright_cyan"
NORD_GREEN = "bright_green"
NORD_YELLOW = "bright_yellow"
NORD_RED = "bright_red"
NORD_DIM = "dim white"

# Import UI components
from utils.ui_components import (
    console, NORD_BLUE, NORD_CYAN, NORD_GREEN, NORD_YELLOW, NORD_RED, NORD_DIM,
    display_ascii_art, create_progress_bar, handle_error
)

# Import settings manager
from utils.settings_manager import configure_settings

def display_menu():
    """Display the main menu"""
    menu_panel = Panel(
        Text.from_markup(
            "\n".join([
                f"[{NORD_BLUE}][1][/{NORD_BLUE}] üé¨ Converter V√≠deos para √Åudio",
                f"[{NORD_BLUE}][2][/{NORD_BLUE}] üìù Transcrever √Åudios (Whisper/Local)",
                f"[{NORD_BLUE}][3][/{NORD_BLUE}] ü§ñ Processar com IA (Claude/ChatGPT)",
                f"[{NORD_BLUE}][4][/{NORD_BLUE}] ‚è±Ô∏è Gerar Timestamps",
                f"[{NORD_BLUE}][5][/{NORD_BLUE}] üéôÔ∏è Criar √Åudio TTS",
                f"[{NORD_BLUE}][6][/{NORD_BLUE}] üìä Gerar XML Podcast",
                f"[{NORD_BLUE}][7][/{NORD_BLUE}] ‚òÅÔ∏è Upload Google Drive",
                f"[{NORD_BLUE}][8][/{NORD_BLUE}] üîó Atualizar GitHub",
                f"[{NORD_BLUE}][9][/{NORD_BLUE}] üîÑ Processar Curso Completo",
                f"[{NORD_BLUE}][10][/{NORD_BLUE}] ‚öôÔ∏è Configura√ß√µes",
                f"[{NORD_BLUE}][0][/{NORD_BLUE}] ‚Üê Sair"
            ])
        ),
        title="[bold]Menu Principal[/bold]",
        border_style=NORD_CYAN,
        padding=(1, 2)
    )
    console.print(menu_panel)

def convert_videos():
    """Convert videos to audio"""
    try:
        console.print(f"[{NORD_CYAN}]Iniciando convers√£o de v√≠deos para √°udio...[/{NORD_CYAN}]")
        
        # Get input directory
        input_dir = Prompt.ask("[bold]Diret√≥rio com v√≠deos", default=settings.get_default_video_dir())
        
        # Get output directory
        output_dir = Prompt.ask("[bold]Diret√≥rio para salvar √°udios", default=settings.get_default_audio_dir())
        
        # Get file extension filter
        extensions = Prompt.ask("[bold]Extens√µes de v√≠deo (separadas por v√≠rgula)", default="mp4,mkv,avi,mov")
        ext_list = [ext.strip() for ext in extensions.split(",")]
        
        # Ensure directories exist
        file_manager.ensure_directory_exists(input_dir)
        file_manager.ensure_directory_exists(output_dir)
        
        # Import audio converter module
        from modules import audio_converter
        
        # Get video files
        video_files = file_manager.get_files_by_extensions(input_dir, ext_list)
        
        if not video_files:
            console.print(f"[{NORD_YELLOW}]Nenhum arquivo de v√≠deo encontrado em {input_dir}[/{NORD_YELLOW}]")
            return
        
        # Display files to be converted
        console.print(f"[{NORD_GREEN}]Encontrados {len(video_files)} arquivos de v√≠deo[/{NORD_GREEN}]")
        
        # Ask for confirmation
        if not Confirm.ask("[bold]Deseja converter todos os arquivos?"):
            console.print(f"[{NORD_YELLOW}]Opera√ß√£o cancelada pelo usu√°rio[/{NORD_YELLOW}]")
            return
        
        # Convert videos to audio
        converter = audio_converter.AudioConverter(console=console)
        
        results = converter.batch_convert(
            video_files=video_files,
            output_dir=output_dir,
            audio_format="mp3",
            audio_quality="192k"
        )
        
        # Display results
        if results["converted"]:
            console.print(f"[{NORD_GREEN}]Convers√£o conclu√≠da com sucesso![/{NORD_GREEN}]")
            
            # Display converted files
            console.print(f"[{NORD_CYAN}]Arquivos convertidos:[/{NORD_CYAN}]")
            
            table = Table(show_header=True, header_style=NORD_BLUE)
            table.add_column("Arquivo de V√≠deo")
            table.add_column("Arquivo de √Åudio")
            
            for item in results["converted"]:
                table.add_row(
                    os.path.basename(item["video_path"]),
                    os.path.basename(item["audio_path"])
                )
            
            console.print(table)
        
        # Display failed conversions
        if results["failed"]:
            console.print(f"[{NORD_RED}]Falhas na convers√£o:[/{NORD_RED}]")
            
            table = Table(show_header=True, header_style=NORD_RED)
            table.add_column("Arquivo de V√≠deo")
            table.add_column("Erro")
            
            for item in results["failed"]:
                table.add_row(
                    os.path.basename(item["video_path"]),
                    item["error"]
                )
            
            console.print(table)
        
    except Exception as e:
        handle_error("Erro ao converter v√≠deos", e)

def transcribe_audio():
    """Transcribe audio files"""
    try:
        console.print(f"[{NORD_CYAN}]Iniciando transcri√ß√£o de √°udios...[/{NORD_CYAN}]")
        
        # Get input directory
        input_dir = Prompt.ask("[bold]Diret√≥rio com √°udios", default=settings.get_default_audio_dir())
        
        # Get output directory
        output_dir = Prompt.ask("[bold]Diret√≥rio para salvar transcri√ß√µes", default=settings.get_default_transcription_dir())
        
        # Get file extension filter
        extensions = Prompt.ask("[bold]Extens√µes de √°udio (separadas por v√≠rgula)", default="mp3,wav,m4a,ogg")
        ext_list = [ext.strip() for ext in extensions.split(",")]
        
        # Ensure directories exist
        file_manager.ensure_directory_exists(input_dir)
        file_manager.ensure_directory_exists(output_dir)
        
        # Import transcription module
        from modules import transcription
        
        # Get audio files
        audio_files = file_manager.get_files_by_extensions(input_dir, ext_list)
        
        if not audio_files:
            console.print(f"[{NORD_YELLOW}]Nenhum arquivo de √°udio encontrado em {input_dir}[/{NORD_YELLOW}]")
            return
        
        # Display files to be transcribed
        console.print(f"[{NORD_GREEN}]Encontrados {len(audio_files)} arquivos de √°udio[/{NORD_GREEN}]")
        
        # Ask for confirmation
        if not Confirm.ask("[bold]Deseja transcrever todos os arquivos?"):
            console.print(f"[{NORD_YELLOW}]Opera√ß√£o cancelada pelo usu√°rio[/{NORD_YELLOW}]")
            return
        
        # Ask for transcription method
        method_choices = ["openai_api", "docker_local", "auto"]
        method = Prompt.ask("[bold]M√©todo de transcri√ß√£o", choices=method_choices, default="auto")
        
        # Ask for model
        model_choices = ["tiny", "base", "small", "medium", "large"]
        model = Prompt.ask("[bold]Modelo Whisper", choices=model_choices, default="medium")
        
        # Ask for language
        language_choices = ["pt", "en", "auto"]
        language = Prompt.ask("[bold]Idioma", choices=language_choices, default="pt")
        
        # Check if method is available
        if method == "docker_local" or method == "auto":
            # Check if Docker is available
            docker_available = transcription.check_docker_available()
            
            if not docker_available:
                console.print(f"[{NORD_YELLOW}]Docker n√£o est√° dispon√≠vel para transcri√ß√£o local.[/{NORD_YELLOW}]")
                
                if method == "docker_local":
                    if Confirm.ask("[bold]Deseja usar a API OpenAI como alternativa?"):
                        method = "openai_api"
                    else:
                        return
                else:  # method == "auto"
                    method = "openai_api"
                    console.print(f"[{NORD_YELLOW}]Usando API OpenAI como alternativa.[/{NORD_YELLOW}]")
        
        # Initialize transcriber
        transcriber = transcription.WhisperTranscriber(
            model=model,
            language=language,
            console=console
        )
        
        # Batch transcribe audio files
        success, results = transcriber.batch_transcribe(
            audio_paths=audio_files,
            output_dir=output_dir,
            method=method
        )
        
        # Display results
        if success:
            console.print(f"[{NORD_GREEN}]Transcri√ß√£o conclu√≠da com sucesso![/{NORD_GREEN}]")
            
            # Display transcribed files
            if results["transcribed"]:
                console.print(f"[{NORD_CYAN}]Arquivos transcritos:[/{NORD_CYAN}]")
                
                table = Table(show_header=True, header_style=NORD_BLUE)
                table.add_column("Arquivo de √Åudio")
                table.add_column("Arquivo de Transcri√ß√£o")
                
                for item in results["transcribed"]:
                    table.add_row(
                        os.path.basename(item["audio_path"]),
                        os.path.basename(item["output_path"])
                    )
                
                console.print(table)
        else:
            console.print(f"[{NORD_RED}]Erro na transcri√ß√£o: {results.get('error', 'Erro desconhecido')}[/{NORD_RED}]")
            
            # Display failed files
            if results.get("failed"):
                console.print(f"[{NORD_RED}]Arquivos com erro:[/{NORD_RED}]")
                
                table = Table(show_header=True, header_style=NORD_RED)
                table.add_column("Arquivo de √Åudio")
                table.add_column("Erro")
                
                for item in results["failed"]:
                    table.add_row(
                        os.path.basename(item["audio_path"]),
                        item["error"]
                    )
                
                console.print(table)
        
    except Exception as e:
        handle_error("Erro ao transcrever √°udios", e)

def process_with_ai():
    """Process transcriptions with AI"""
    try:
        console.print(f"[{NORD_CYAN}]Iniciando processamento com IA...[/{NORD_CYAN}]")
        
        # Get input directory
        input_dir = Prompt.ask("[bold]Diret√≥rio com transcri√ß√µes", default=settings.get_default_transcription_dir())
        
        # Get output directory
        output_dir = Prompt.ask("[bold]Diret√≥rio para salvar processados", default=settings.get_default_processed_dir())
        
        # Ensure directories exist
        file_manager.ensure_directory_exists(input_dir)
        file_manager.ensure_directory_exists(output_dir)
        
        # Import AI processor module
        from modules import ai_processor
        
        # Get text files
        text_files = file_manager.get_text_files(input_dir)
        
        if not text_files:
            console.print(f"[{NORD_YELLOW}]Nenhum arquivo de texto encontrado em {input_dir}[/{NORD_YELLOW}]")
            return
        
        # Display files to be processed
        console.print(f"[{NORD_GREEN}]Encontrados {len(text_files)} arquivos de texto[/{NORD_GREEN}]")
        
        # Ask for AI model
        model_choices = ["claude", "chatgpt", "auto"]
        model = Prompt.ask("[bold]Modelo de IA", choices=model_choices, default="auto")
        
        # Ask for prompt template
        from pathlib import Path
        prompt_dir = Path("prompts")
        prompt_files = list(prompt_dir.glob("*.txt"))
        
        if not prompt_files:
            console.print(f"[{NORD_YELLOW}]Nenhum arquivo de prompt encontrado em {prompt_dir}[/{NORD_YELLOW}]")
            return
        
        prompt_choices = [f.stem for f in prompt_files]
        prompt_template = Prompt.ask("[bold]Template de prompt", choices=prompt_choices, default="default_prompt")
        
        # Initialize AI processor
        processor = ai_processor.AIProcessor(
            model=model,
            console=console
        )
        
        # Load prompt template
        prompt_path = prompt_dir / f"{prompt_template}.txt"
        processor.load_prompt_template(prompt_path)
        
        # Process each file
        results = {"success": [], "failed": []}
        
        with Progress(
            TextColumn(f"[{NORD_BLUE}]{{task.description}}[/{NORD_BLUE}]"),
            BarColumn(),
            TaskProgressColumn(),
            console=console
        ) as progress:
            task = progress.add_task(f"[{NORD_CYAN}]Processando arquivos...[/{NORD_CYAN}]", total=len(text_files))
            
            for text_file in text_files:
                # Generate output path
                output_filename = os.path.splitext(os.path.basename(text_file))[0] + ".md"
                output_path = os.path.join(output_dir, output_filename)
                
                # Process file
                success, result = processor.process_file(
                    input_path=text_file,
                    output_path=output_path
                )
                
                if success:
                    results["success"].append((text_file, output_path))
                else:
                    results["failed"].append((text_file, result))
                
                progress.update(task, advance=1)
        
        # Display results
        if results["success"]:
            console.print(f"[{NORD_GREEN}]Processamento conclu√≠do com sucesso para {len(results['success'])} arquivos![/{NORD_GREEN}]")
            
            # Display processed files
            console.print(f"[{NORD_CYAN}]Arquivos processados:[/{NORD_CYAN}]")
            
            table = Table(show_header=True, header_style=NORD_BLUE)
            table.add_column("Arquivo de Texto")
            table.add_column("Arquivo Processado")
            
            for text_file, output_path in results["success"]:
                table.add_row(
                    os.path.basename(text_file),
                    os.path.basename(output_path)
                )
            
            console.print(table)
        
        if results["failed"]:
            console.print(f"[{NORD_RED}]Falha no processamento para {len(results['failed'])} arquivos:[/{NORD_RED}]")
            
            table = Table(show_header=True, header_style=NORD_RED)
            table.add_column("Arquivo de Texto")
            table.add_column("Erro")
            
            for text_file, error in results["failed"]:
                table.add_row(
                    os.path.basename(text_file),
                    str(error)
                )
            
            console.print(table)
        
    except Exception as e:
        handle_error("Erro ao processar com IA", e)

def generate_timestamps():
    """Generate timestamps for transcriptions"""
    try:
        console.print(f"[{NORD_CYAN}]Iniciando gera√ß√£o de timestamps...[/{NORD_CYAN}]")
        
        # Ask for source type
        source_choices = ["markdown", "whisper", "text"]
        source_type = Prompt.ask("[bold]Tipo de fonte", choices=source_choices, default="markdown")
        
        if source_type == "markdown":
            # Get input directory
            input_dir = Prompt.ask("[bold]Diret√≥rio com arquivos markdown", default=settings.get_default_processed_dir())
            
            # Get output directory
            output_dir = Prompt.ask("[bold]Diret√≥rio para salvar timestamps", default=input_dir)
            
            # Ask for format type
            format_choices = ["json", "csv", "txt"]
            format_type = Prompt.ask("[bold]Formato de sa√≠da", choices=format_choices, default="json")
            
            # Ask if recursive
            recursive = Confirm.ask("[bold]Buscar arquivos recursivamente?", default=True)
            
            # Ensure directories exist
            file_manager.ensure_directory_exists(input_dir)
            file_manager.ensure_directory_exists(output_dir)
            
            # Import timestamp generator module
            from modules import timestamp_generator
            
            # Generate timestamps
            success, results = timestamp_generator.batch_generate_timestamps_from_markdown(
                markdown_dir=input_dir,
                output_dir=output_dir,
                format_type=format_type,
                recursive=recursive,
                console=console
            )
            
            # Display results
            if success:
                console.print(f"[{NORD_GREEN}]Gera√ß√£o de timestamps conclu√≠da com sucesso![/{NORD_GREEN}]")
                
                # Display processed files
                if results["processed"]:
                    console.print(f"[{NORD_CYAN}]Arquivos processados:[/{NORD_CYAN}]")
                    
                    table = Table(show_header=True, header_style=NORD_BLUE)
                    table.add_column("Arquivo Markdown")
                    table.add_column("Arquivo de Timestamps")
                    
                    for item in results["processed"]:
                        table.add_row(
                            os.path.basename(item["markdown_path"]),
                            os.path.basename(item["output_path"])
                        )
                    
                    console.print(table)
            else:
                console.print(f"[{NORD_RED}]Erro na gera√ß√£o de timestamps: {results.get('error', 'Erro desconhecido')}[/{NORD_RED}]")
        
        elif source_type == "whisper":
            # Get input directory
            input_dir = Prompt.ask("[bold]Diret√≥rio com arquivos JSON do Whisper", default=settings.get_default_transcription_dir())
            
            # Get output directory
            output_dir = Prompt.ask("[bold]Diret√≥rio para salvar timestamps", default=input_dir)
            
            # Ensure directories exist
            file_manager.ensure_directory_exists(input_dir)
            file_manager.ensure_directory_exists(output_dir)
            
            # Get JSON files
            json_files = list(Path(input_dir).glob("*.json"))
            
            if not json_files:
                console.print(f"[{NORD_YELLOW}]Nenhum arquivo JSON encontrado em {input_dir}[/{NORD_YELLOW}]")
                return
            
            # Display files to be processed
            console.print(f"[{NORD_GREEN}]Encontrados {len(json_files)} arquivos JSON[/{NORD_GREEN}]")
            
            # Import timestamp generator module
            from modules import timestamp_generator
            
            # Generate timestamps
            results = timestamp_generator.batch_generate_timestamps(
                file_paths=[str(f) for f in json_files],
                output_dir=output_dir,
                is_whisper_json=True
            )
            
            # Count successful generations
            successful = sum(1 for result in results if result[0])
            
            # Display results
            console.print(f"[{NORD_GREEN}]Gera√ß√£o de timestamps conclu√≠da: {successful}/{len(json_files)} arquivos processados com sucesso[/{NORD_GREEN}]")
        
        elif source_type == "text":
            # Get input directory
            input_dir = Prompt.ask("[bold]Diret√≥rio com arquivos de texto", default=settings.get_default_transcription_dir())
            
            # Get output directory
            output_dir = Prompt.ask("[bold]Diret√≥rio para salvar timestamps", default=input_dir)
            
            # Ensure directories exist
            file_manager.ensure_directory_exists(input_dir)
            file_manager.ensure_directory_exists(output_dir)
            
            # Get text files
            text_files = file_manager.get_text_files(input_dir)
            
            if not text_files:
                console.print(f"[{NORD_YELLOW}]Nenhum arquivo de texto encontrado em {input_dir}[/{NORD_YELLOW}]")
                return
            
            # Display files to be processed
            console.print(f"[{NORD_GREEN}]Encontrados {len(text_files)} arquivos de texto[/{NORD_GREEN}]")
            
            # Import timestamp generator module
            from modules import timestamp_generator
            
            # Generate timestamps
            results = timestamp_generator.batch_generate_timestamps(
                file_paths=[str(f) for f in text_files],
                output_dir=output_dir,
                is_whisper_json=False
            )
            
            # Count successful generations
            successful = sum(1 for result in results if result[0])
            
            # Display results
            console.print(f"[{NORD_GREEN}]Gera√ß√£o de timestamps conclu√≠da: {successful}/{len(text_files)} arquivos processados com sucesso[/{NORD_GREEN}]")
        
    except Exception as e:
        handle_error("Erro ao gerar timestamps", e)

def create_tts_audio():
    """Create TTS audio from processed text"""
    try:
        console.print(f"[{NORD_CYAN}]Iniciando gera√ß√£o de √°udio TTS...[/{NORD_CYAN}]")
        
        # Get input directory or file
        input_path = Prompt.ask("[bold]Arquivo ou diret√≥rio com arquivos markdown", default=settings.get_default_processed_dir())
        
        # Get output directory
        output_dir = Prompt.ask("[bold]Diret√≥rio para salvar arquivos de √°udio", default=settings.get_default_audio_dir())
        
        # Ensure directories exist
        file_manager.ensure_directory_exists(output_dir)
        
        # Import TTS generator module
        from modules.tts_generator import EdgeTTSGenerator, VoiceSettings, run_async
        
        # Create TTS generator
        tts = EdgeTTSGenerator(console=console)
        
        # Check if input is a file or directory
        if os.path.isfile(input_path):
            markdown_files = [input_path]
        else:
            # Get markdown files
            markdown_files = file_manager.get_markdown_files(input_path)
        
        if not markdown_files:
            console.print(f"[{NORD_YELLOW}]Nenhum arquivo markdown encontrado em {input_path}[/{NORD_YELLOW}]")
            return
        
        # Display files to be processed
        console.print(f"[{NORD_GREEN}]Encontrados {len(markdown_files)} arquivos markdown[/{NORD_GREEN}]")
        
        # List available voices
        voices = run_async(tts.get_available_voices())
        
        # Group voices by language
        voices_by_language = {}
        for voice in voices:
            lang = voice.get("Locale", "unknown")
            if lang not in voices_by_language:
                voices_by_language[lang] = []
            voices_by_language[lang].append(voice)
        
        # Display available languages
        console.print(f"[{NORD_CYAN}]Idiomas dispon√≠veis:[/{NORD_CYAN}]")
        languages = sorted(voices_by_language.keys())
        
        for i, lang in enumerate(languages):
            console.print(f"[{NORD_BLUE}]{i+1}.[/{NORD_BLUE}] {lang} ({len(voices_by_language[lang])} vozes)")
        
        # Select language
        lang_idx = int(Prompt.ask("[bold]Selecione o idioma (n√∫mero)", default="1")) - 1
        selected_language = languages[lang_idx]
        
        # Display voices for selected language
        console.print(f"[{NORD_CYAN}]Vozes dispon√≠veis para {selected_language}:[/{NORD_CYAN}]")
        
        voices_in_language = voices_by_language[selected_language]
        for i, voice in enumerate(voices_in_language):
            gender = "Feminina" if "Female" in voice.get("Gender", "") else "Masculina"
            console.print(f"[{NORD_BLUE}]{i+1}.[/{NORD_BLUE}] {voice.get('ShortName')} - {voice.get('DisplayName')} ({gender})")
        
        # Select voice
        voice_idx = int(Prompt.ask("[bold]Selecione a voz (n√∫mero)", default="1")) - 1
        selected_voice = voices_in_language[voice_idx]["ShortName"]
        
        # Create voice settings
        voice_settings = VoiceSettings(
            voice=selected_voice,
            rate=Prompt.ask("[bold]Taxa de fala (ex: +0%, -10%, +20%)", default="+0%"),
            volume=Prompt.ask("[bold]Volume (ex: +0%, -10%, +20%)", default="+0%"),
            pitch=Prompt.ask("[bold]Tom (ex: +0Hz, -10Hz, +20Hz)", default="+0Hz")
        )
        
        # Preview voice
        console.print(f"[{NORD_CYAN}]Gerando preview da voz...[/{NORD_CYAN}]")
        preview_text = "Este √© um exemplo de como esta voz soa. Ser√° utilizada para gerar o √°udio do seu curso."
        preview_path = run_async(tts.preview_voice(voice_settings, preview_text))
        
        if preview_path:
            console.print(f"[{NORD_GREEN}]Preview gerado: {preview_path}[/{NORD_GREEN}]")
            
            # Ask to play preview
            if Confirm.ask("[bold]Deseja reproduzir o preview?", default=True):
                # Try to play with different commands based on OS
                try:
                    if sys.platform == "darwin":  # macOS
                        os.system(f"afplay {preview_path}")
                    elif sys.platform == "win32":  # Windows
                        os.system(f"start {preview_path}")
                    else:  # Linux
                        os.system(f"ffplay -nodisp -autoexit {preview_path} 2>/dev/null")
                except:
                    console.print(f"[{NORD_YELLOW}]N√£o foi poss√≠vel reproduzir o √°udio automaticamente.[/{NORD_YELLOW}]")
        
        # Confirm voice selection
        if not Confirm.ask("[bold]Deseja continuar com esta voz?", default=True):
            console.print(f"[{NORD_YELLOW}]Opera√ß√£o cancelada pelo usu√°rio.[/{NORD_YELLOW}]")
            return
        
        # Process each markdown file
        results = {"success": [], "failed": []}
        
        with Progress(
            TextColumn("[bold blue]{task.description}"),
            BarColumn(),
            TaskProgressColumn(),
            console=console
        ) as progress:
            task = progress.add_task(f"[{NORD_CYAN}]Processando arquivos...[/{NORD_CYAN}]", total=len(markdown_files))
            
            for markdown_file in markdown_files:
                # Generate output path
                output_filename = os.path.splitext(os.path.basename(markdown_file))[0] + ".mp3"
                output_path = os.path.join(output_dir, output_filename)
                
                # Generate audio
                success, result = run_async(tts.generate_audio_from_markdown(
                    markdown_path=markdown_file,
                    output_path=output_path,
                    voice_settings=voice_settings
                ))
                
                if success:
                    results["success"].append((markdown_file, output_path))
                else:
                    results["failed"].append((markdown_file, result))
                
                progress.update(task, advance=1)
        
        # Display results
        if results["success"]:
            console.print(f"[{NORD_GREEN}]Gera√ß√£o de √°udio conclu√≠da com sucesso para {len(results['success'])} arquivos![/{NORD_GREEN}]")
            
            # Display processed files
            console.print(f"[{NORD_CYAN}]Arquivos processados:[/{NORD_CYAN}]")
            
            table = Table(show_header=True, header_style=NORD_BLUE)
            table.add_column("Arquivo Markdown")
            table.add_column("Arquivo de √Åudio")
            
            for markdown_file, audio_file in results["success"]:
                table.add_row(
                    os.path.basename(markdown_file),
                    os.path.basename(audio_file)
                )
            
            console.print(table)
        
        if results["failed"]:
            console.print(f"[{NORD_RED}]Falha na gera√ß√£o de √°udio para {len(results['failed'])} arquivos:[/{NORD_RED}]")
            
            table = Table(show_header=True, header_style=NORD_RED)
            table.add_column("Arquivo Markdown")
            table.add_column("Erro")
            
            for markdown_file, error in results["failed"]:
                table.add_row(
                    os.path.basename(markdown_file),
                    str(error)
                )
            
            console.print(table)
        
    except Exception as e:
        handle_error("Erro ao gerar √°udio TTS", e)

def generate_xml():
    """Generate XML podcast feed"""
    try:
        console.print(f"[{NORD_CYAN}]Iniciando gera√ß√£o de XML para podcast...[/{NORD_CYAN}]")
        
        # Import XML generator module
        from modules import xml_generator
        
        # Get course information
        course_title = Prompt.ask("[bold]T√≠tulo do curso")
        course_description = Prompt.ask("[bold]Descri√ß√£o do curso")
        course_author = Prompt.ask("[bold]Autor do curso")
        course_language = Prompt.ask("[bold]Idioma do curso (ex: pt-br)", default="pt-br")
        course_category = Prompt.ask("[bold]Categoria do curso", default="Education")
        course_image_url = Prompt.ask("[bold]URL da imagem do curso (opcional)")
        
        # Get audio directory
        audio_dir = Prompt.ask("[bold]Diret√≥rio com arquivos de √°udio", default=settings.get_default_audio_dir())
        
        # Get output directory
        output_dir = Prompt.ask("[bold]Diret√≥rio para salvar XML", default=settings.get_default_xml_dir())
        
        # Get output filename
        output_filename = Prompt.ask("[bold]Nome do arquivo XML", default="podcast.xml")
        
        # Ensure directories exist
        file_manager.ensure_directory_exists(audio_dir)
        file_manager.ensure_directory_exists(output_dir)
        
        # Get audio files
        audio_files = file_manager.get_files_by_extensions(audio_dir, ["mp3"])
        
        if not audio_files:
            console.print(f"[{NORD_YELLOW}]Nenhum arquivo de √°udio encontrado em {audio_dir}[/{NORD_YELLOW}]")
            return
        
        # Display files to be included
        console.print(f"[{NORD_GREEN}]Encontrados {len(audio_files)} arquivos de √°udio[/{NORD_GREEN}]")
        
        # Ask for base URL
        base_url = Prompt.ask("[bold]URL base para os arquivos de √°udio")
        
        # Create XML generator
        generator = xml_generator.PodcastXMLGenerator(
            title=course_title,
            description=course_description,
            author=course_author,
            language=course_language,
            category=course_category,
            image_url=course_image_url if course_image_url else None
        )
        
        # Add episodes
        with Progress(
            TextColumn(f"[{NORD_BLUE}]{{task.description}}[/{NORD_BLUE}]"),
            BarColumn(),
            TaskProgressColumn(),
            console=console
        ) as progress:
            task = progress.add_task(f"[{NORD_CYAN}]Adicionando epis√≥dios...[/{NORD_CYAN}]", total=len(audio_files))
            
            for audio_file in audio_files:
                # Get episode title from filename
                episode_title = os.path.splitext(os.path.basename(audio_file))[0]
                
                # Look for corresponding markdown file
                markdown_path = os.path.join(
                    settings.get_default_processed_dir(),
                    f"{episode_title}.md"
                )
                
                episode_description = ""
                if os.path.exists(markdown_path):
                    with open(markdown_path, 'r', encoding='utf-8') as f:
                        # Read first 500 characters as description
                        episode_description = f.read(500) + "..."
                
                # Look for corresponding timestamp file
                timestamp_path = os.path.join(
                    os.path.dirname(audio_file),
                    f"{episode_title}.json"
                )
                
                timestamps = None
                if os.path.exists(timestamp_path):
                    try:
                        import json
                        with open(timestamp_path, 'r', encoding='utf-8') as f:
                            timestamps = json.load(f)
                    except:
                        pass
                
                # Generate episode URL
                episode_url = f"{base_url.rstrip('/')}/{os.path.basename(audio_file)}"
                
                # Add episode
                generator.add_episode(
                    title=episode_title,
                    audio_url=episode_url,
                    description=episode_description,
                    timestamps=timestamps
                )
                
                progress.update(task, advance=1)
        
        # Generate XML
        output_path = os.path.join(output_dir, output_filename)
        generator.generate_xml(output_path)
        
        console.print(f"[{NORD_GREEN}]XML gerado com sucesso: {output_path}[/{NORD_GREEN}]")
        
        # Generate timestamps markdown
        timestamps_md_path = os.path.join(output_dir, "timestamps.md")
        generator.generate_timestamps_markdown(timestamps_md_path)
        
        console.print(f"[{NORD_GREEN}]Markdown de timestamps gerado: {timestamps_md_path}[/{NORD_GREEN}]")
        
    except Exception as e:
        handle_error("Erro ao gerar XML", e)

def upload_to_drive():
    """Upload files to Google Drive"""
    try:
        console.print(f"[{NORD_CYAN}]Iniciando upload para Google Drive...[/{NORD_CYAN}]")
        
        # Import Drive uploader module
        from modules import drive_uploader
        
        # Get input directory
        input_dir = Prompt.ask("[bold]Diret√≥rio com arquivos para upload", default=settings.get_default_audio_dir())
        
        # Get file extensions
        extensions = Prompt.ask("[bold]Extens√µes de arquivo (separadas por v√≠rgula)", default="mp3,xml,md")
        ext_list = [ext.strip() for ext in extensions.split(",")]
        
        # Ensure directory exists
        file_manager.ensure_directory_exists(input_dir)
        
        # Get files
        files = file_manager.get_files_by_extensions(input_dir, ext_list)
        
        if not files:
            console.print(f"[{NORD_YELLOW}]Nenhum arquivo encontrado em {input_dir} com as extens√µes {', '.join(ext_list)}[/{NORD_YELLOW}]")
            return
        
        # Display files to be uploaded
        console.print(f"[{NORD_GREEN}]Encontrados {len(files)} arquivos para upload[/{NORD_GREEN}]")
        
        # Ask for Drive folder name
        folder_name = Prompt.ask("[bold]Nome da pasta no Google Drive")
        
        # Ask for sharing options
        share_publicly = Confirm.ask("[bold]Compartilhar pasta publicamente?", default=True)
        
        # Create Drive uploader
        uploader = drive_uploader.GoogleDriveManager(console=console)
        
        # Authenticate
        if not uploader.authenticate():
            console.print(f"[{NORD_RED}]Falha na autentica√ß√£o com o Google Drive[/{NORD_RED}]")
            return
        
        # Create folder
        folder_id = uploader.create_folder(folder_name)
        
        if not folder_id:
            console.print(f"[{NORD_RED}]Falha ao criar pasta no Google Drive[/{NORD_RED}]")
            return
        
        console.print(f"[{NORD_GREEN}]Pasta criada no Google Drive: {folder_name} (ID: {folder_id})[/{NORD_GREEN}]")
        
        # Upload files
        results = {"success": [], "failed": []}
        
        with Progress(
            TextColumn(f"[{NORD_BLUE}]{{task.description}}[/{NORD_BLUE}]"),
            BarColumn(),
            TaskProgressColumn(),
            console=console
        ) as progress:
            task = progress.add_task(f"[{NORD_CYAN}]Fazendo upload de arquivos...[/{NORD_CYAN}]", total=len(files))
            
            for file_path in files:
                # Upload file
                file_id = uploader.upload_file(
                    file_path=file_path,
                    folder_id=folder_id
                )
                
                if file_id:
                    results["success"].append((file_path, file_id))
                else:
                    results["failed"].append(file_path)
                
                progress.update(task, advance=1)
        
        # Share folder if requested
        if share_publicly and folder_id:
            share_link = uploader.share_folder(folder_id)
            
            if share_link:
                console.print(f"[{NORD_GREEN}]Pasta compartilhada publicamente: {share_link}[/{NORD_GREEN}]")
            else:
                console.print(f"[{NORD_RED}]Falha ao compartilhar pasta[/{NORD_RED}]")
        
        # Display results
        if results["success"]:
            console.print(f"[{NORD_GREEN}]Upload conclu√≠do com sucesso para {len(results['success'])} arquivos![/{NORD_GREEN}]")
            
            # Display uploaded files
            console.print(f"[{NORD_CYAN}]Arquivos enviados:[/{NORD_CYAN}]")
            
            table = Table(show_header=True, header_style=NORD_BLUE)
            table.add_column("Arquivo")
            table.add_column("ID no Google Drive")
            
            for file_path, file_id in results["success"]:
                table.add_row(
                    os.path.basename(file_path),
                    file_id
                )
            
            console.print(table)
        
        if results["failed"]:
            console.print(f"[{NORD_RED}]Falha no upload para {len(results['failed'])} arquivos:[/{NORD_RED}]")
            
            table = Table(show_header=True, header_style=NORD_RED)
            table.add_column("Arquivo")
            
            for file_path in results["failed"]:
                table.add_row(os.path.basename(file_path))
            
            console.print(table)
        
    except Exception as e:
        handle_error("Erro ao fazer upload para o Google Drive", e)

def update_github():
    """Update GitHub repository"""
    try:
        console.print(f"[{NORD_CYAN}]Iniciando atualiza√ß√£o do GitHub...[/{NORD_CYAN}]")
        
        # Import GitHub manager module
        from modules import github_manager_fixed as github_manager
        
        # Get local repository path
        repo_path = Prompt.ask("[bold]Caminho do reposit√≥rio local", default=settings.get_default_github_dir())
        
        # Ensure directory exists
        file_manager.ensure_directory_exists(repo_path)
        
        # Create GitHub manager
        # Get GitHub credentials
        github_credentials = credentials.get_github_credentials()
        
        # Create GitHub manager
        manager = github_manager.GitHubManager(
            repo_path=repo_path,
            credentials=github_credentials
        )
        
        # Check if repository is valid
        if not manager.is_valid_repository():
            console.print(f"[{NORD_RED}]O diret√≥rio {repo_path} n√£o √© um reposit√≥rio Git v√°lido[/{NORD_RED}]")
            
            # Ask if user wants to clone a repository
            if Confirm.ask("[bold]Deseja clonar um reposit√≥rio?"):
                repo_url = Prompt.ask("[bold]URL do reposit√≥rio")
                
                # Clone repository
                success, message = manager.clone_repository(repo_url, repo_path)
                if success:
                    console.print(f"[{NORD_GREEN}]Reposit√≥rio clonado com sucesso![/{NORD_GREEN}]")
                else:
                    console.print(f"[{NORD_RED}]Falha ao clonar reposit√≥rio: {message}[/{NORD_RED}]")
                    return
            else:
                return
        
        # Get repository status
        status = manager.get_status()
        
        console.print(f"[{NORD_CYAN}]Status do reposit√≥rio:[/{NORD_CYAN}]")
        
        if "error" in status:
            console.print(f"[{NORD_RED}]{status['error']}[/{NORD_RED}]")
            return
            
        # Display repository information
        console.print(f"Branch atual: [{NORD_GREEN}]{status.get('current_branch', 'N/A')}[/{NORD_GREEN}]")
        
        # Display remotes
        if status.get('remotes'):
            console.print(f"[{NORD_CYAN}]Remotes:[/{NORD_CYAN}]")
            for name, url in status.get('remotes', {}).items():
                console.print(f"  {name}: [{NORD_BLUE}]{url}[/{NORD_BLUE}]")
        
        # Display modified files
        if status.get('modified_files'):
            console.print(f"[{NORD_YELLOW}]Arquivos modificados:[/{NORD_YELLOW}]")
            for file in status.get('modified_files', []):
                console.print(f"  [{NORD_YELLOW}]{file}[/{NORD_YELLOW}]")
                
        # Display untracked files
        if status.get('untracked_files'):
            console.print(f"[{NORD_RED}]Arquivos n√£o rastreados:[/{NORD_RED}]")
            for file in status.get('untracked_files', []):
                console.print(f"  [{NORD_RED}]{file}[/{NORD_RED}]")
        
        # Ask what to do
        action_choices = ["commit", "push", "pull", "status"]
        action = Prompt.ask("[bold]A√ß√£o", choices=action_choices, default="status")
        
        if action == "commit":
            # Get files to add
            files_to_add = Prompt.ask("[bold]Arquivos para adicionar (separados por espa√ßo, ou '.' para todos)")
            
            # Get commit message
            commit_message = Prompt.ask("[bold]Mensagem do commit")
            
            # Add files
            if files_to_add == ".":
                success = manager.add_all()
            else:
                file_list = files_to_add.split()
                success = manager.add_files(file_list)
            
            if not success:
                console.print(f"[{NORD_RED}]Falha ao adicionar arquivos[/{NORD_RED}]")
                return
            
            # Commit changes
            if manager.commit(commit_message):
                console.print(f"[{NORD_GREEN}]Altera√ß√µes commitadas com sucesso![/{NORD_GREEN}]")
            else:
                console.print(f"[{NORD_RED}]Falha ao commitar altera√ß√µes[/{NORD_RED}]")
        
        elif action == "push":
            # Get branch name
            branch = Prompt.ask("[bold]Nome da branch", default="main")
            
            # Push changes
            if manager.push(branch):
                console.print(f"[{NORD_GREEN}]Altera√ß√µes enviadas com sucesso![/{NORD_GREEN}]")
            else:
                console.print(f"[{NORD_RED}]Falha ao enviar altera√ß√µes[/{NORD_RED}]")
        
        elif action == "pull":
            # Get branch name
            branch = Prompt.ask("[bold]Nome da branch", default="main")
            
            # Pull changes
            if manager.pull(branch):
                console.print(f"[{NORD_GREEN}]Altera√ß√µes baixadas com sucesso![/{NORD_GREEN}]")
            else:
                console.print(f"[{NORD_RED}]Falha ao baixar altera√ß√µes[/{NORD_RED}]")
        
        elif action == "status":
            # Already displayed status above
            pass
        
    except Exception as e:
        handle_error("Erro ao atualizar GitHub", e)

def process_complete_course():
    """Process a complete course from start to finish"""
    try:
        console.print(f"[{NORD_CYAN}]Iniciando processamento completo de curso...[/{NORD_CYAN}]")
        
        # Get course name
        course_name = Prompt.ask("[bold]Nome do curso")
        
        # Create course directory structure
        course_dir = os.path.join(settings.get_default_base_dir(), course_name)
        
        # Create file manager
        from utils.file_manager import CourseFileManager
        
        course_manager = CourseFileManager(
            course_name=course_name,
            base_dir=settings.get_default_base_dir(),
            console=console
        )
        
        # Create course structure
        if course_manager.create_course_structure():
            console.print(f"[{NORD_GREEN}]Estrutura do curso criada com sucesso![/{NORD_GREEN}]")
        else:
            console.print(f"[{NORD_RED}]Falha ao criar estrutura do curso[/{NORD_RED}]")
            return
        
        # Ask for video directory
        video_dir = Prompt.ask("[bold]Diret√≥rio com v√≠deos do curso")
        
        if not os.path.exists(video_dir):
            console.print(f"[{NORD_RED}]Diret√≥rio de v√≠deos n√£o encontrado: {video_dir}[/{NORD_RED}]")
            return
        
        # Get video files
        video_files = file_manager.get_files_by_extensions(video_dir, ["mp4", "mkv", "avi", "mov"])
        
        if not video_files:
            console.print(f"[{NORD_YELLOW}]Nenhum arquivo de v√≠deo encontrado em {video_dir}[/{NORD_YELLOW}]")
            return
        
        # Display files to be processed
        console.print(f"[{NORD_GREEN}]Encontrados {len(video_files)} arquivos de v√≠deo[/{NORD_GREEN}]")
        
        # Ask for confirmation
        if not Confirm.ask("[bold]Deseja processar todos os arquivos?"):
            console.print(f"[{NORD_YELLOW}]Opera√ß√£o cancelada pelo usu√°rio[/{NORD_YELLOW}]")
            return
        
        # Step 1: Convert videos to audio
        console.print(f"[{NORD_CYAN}]Etapa 1: Convertendo v√≠deos para √°udio...[/{NORD_CYAN}]")
        
        from modules import audio_converter
        
        converter = audio_converter.AudioConverter(console=console)
        
        audio_results = converter.batch_convert(
            video_files=video_files,
            output_dir=course_manager.get_audio_dir(),
            audio_format="mp3",
            audio_quality="192k"
        )
        
        if not audio_results["converted"]:
            console.print(f"[{NORD_RED}]Falha ao converter v√≠deos para √°udio[/{NORD_RED}]")
            return
        
        audio_files = [item["audio_path"] for item in audio_results["converted"]]
        
        console.print(f"[{NORD_GREEN}]Convers√£o conclu√≠da: {len(audio_files)} arquivos de √°udio gerados[/{NORD_GREEN}]")
        
        # Step 2: Transcribe audio files
        console.print(f"[{NORD_CYAN}]Etapa 2: Transcrevendo √°udios...[/{NORD_CYAN}]")
        
        from modules import transcription
        
        # Ask for transcription method
        method_choices = ["openai_api", "docker_local", "auto"]
        method = Prompt.ask("[bold]M√©todo de transcri√ß√£o", choices=method_choices, default="auto")
        
        # Ask for model
        model_choices = ["tiny", "base", "small", "medium", "large"]
        model = Prompt.ask("[bold]Modelo Whisper", choices=model_choices, default="medium")
        
        # Ask for language
        language_choices = ["pt", "en", "auto"]
        language = Prompt.ask("[bold]Idioma", choices=language_choices, default="pt")
        
        # Initialize transcriber
        transcriber = transcription.WhisperTranscriber(
            model=model,
            language=language,
            console=console
        )
        
        # Batch transcribe audio files
        transcription_success, transcription_results = transcriber.batch_transcribe(
            audio_paths=audio_files,
            output_dir=course_manager.get_transcription_dir(),
            method=method
        )
        
        if not transcription_success:
            console.print(f"[{NORD_RED}]Falha na transcri√ß√£o: {transcription_results.get('error', 'Erro desconhecido')}[/{NORD_RED}]")
            return
        
        transcription_files = [item["output_path"] for item in transcription_results["transcribed"]]
        
        console.print(f"[{NORD_GREEN}]Transcri√ß√£o conclu√≠da: {len(transcription_files)} arquivos transcritos[/{NORD_GREEN}]")
        
        # Step 3: Process with AI
        console.print(f"[{NORD_CYAN}]Etapa 3: Processando com IA...[/{NORD_CYAN}]")
        
        from modules import ai_processor
        
        # Ask for AI model
        model_choices = ["claude", "chatgpt", "auto"]
        ai_model = Prompt.ask("[bold]Modelo de IA", choices=model_choices, default="auto")
        
        # Ask for prompt template
        from pathlib import Path
        prompt_dir = Path("prompts")
        prompt_files = list(prompt_dir.glob("*.txt"))
        
        if not prompt_files:
            console.print(f"[{NORD_YELLOW}]Nenhum arquivo de prompt encontrado em {prompt_dir}[/{NORD_YELLOW}]")
            return
        
        prompt_choices = [f.stem for f in prompt_files]
        prompt_template = Prompt.ask("[bold]Template de prompt", choices=prompt_choices, default="default_prompt")
        
        # Initialize AI processor
        processor = ai_processor.AIProcessor(
            model=ai_model,
            console=console
        )
        
        # Load prompt template
        prompt_path = prompt_dir / f"{prompt_template}.txt"
        processor.load_prompt_template(prompt_path)
        
        # Process each file
        ai_results = {"success": [], "failed": []}
        
        with Progress(
            TextColumn(f"[{NORD_BLUE}]{{task.description}}[/{NORD_BLUE}]"),
            BarColumn(),
            TaskProgressColumn(),
            console=console
        ) as progress:
            task = progress.add_task(f"[{NORD_CYAN}]Processando arquivos com IA...[/{NORD_CYAN}]", total=len(transcription_files))
            
            for text_file in transcription_files:
                # Generate output path
                output_filename = os.path.splitext(os.path.basename(text_file))[0] + ".md"
                output_path = os.path.join(course_manager.get_processed_dir(), output_filename)
                
                # Process file
                success, result = processor.process_file(
                    input_path=text_file,
                    output_path=output_path
                )
                
                if success:
                    ai_results["success"].append((text_file, output_path))
                else:
                    ai_results["failed"].append((text_file, result))
                
                progress.update(task, advance=1)
        
        if not ai_results["success"]:
            console.print(f"[{NORD_RED}]Falha no processamento com IA[/{NORD_RED}]")
            return
        
        processed_files = [item[1] for item in ai_results["success"]]
        
        console.print(f"[{NORD_GREEN}]Processamento com IA conclu√≠do: {len(processed_files)} arquivos processados[/{NORD_GREEN}]")
        
        # Step 4: Generate timestamps
        console.print(f"[{NORD_CYAN}]Etapa 4: Gerando timestamps...[/{NORD_CYAN}]")
        
        from modules import timestamp_generator
        
        # Generate timestamps from markdown
        timestamp_success, timestamp_results = timestamp_generator.batch_generate_timestamps_from_markdown(
            markdown_dir=course_manager.get_processed_dir(),
            output_dir=course_manager.get_processed_dir(),
            format_type="json",
            recursive=False,
            console=console
        )
        
        if not timestamp_success:
            console.print(f"[{NORD_RED}]Falha na gera√ß√£o de timestamps: {timestamp_results.get('error', 'Erro desconhecido')}[/{NORD_RED}]")
            return
        
        timestamp_files = [item["output_path"] for item in timestamp_results["processed"]]
        
        console.print(f"[{NORD_GREEN}]Gera√ß√£o de timestamps conclu√≠da: {len(timestamp_files)} arquivos de timestamps gerados[/{NORD_GREEN}]")
        
        # Step 5: Generate TTS audio
        console.print(f"[{NORD_CYAN}]Etapa 5: Gerando √°udio TTS...[/{NORD_CYAN}]")
        
        # Ask if user wants to generate TTS
        if not Confirm.ask("[bold]Deseja gerar √°udio TTS?", default=True):
            console.print(f"[{NORD_YELLOW}]Gera√ß√£o de TTS pulada pelo usu√°rio[/{NORD_YELLOW}]")
        else:
            from modules.tts_generator import EdgeTTSGenerator, VoiceSettings, run_async
            
            # Create TTS generator
            tts = EdgeTTSGenerator(console=console)
            
            # List available voices
            voices = run_async(tts.get_available_voices())
            
            # Group voices by language
            voices_by_language = {}
            for voice in voices:
                lang = voice.get("Locale", "unknown")
                if lang not in voices_by_language:
                    voices_by_language[lang] = []
                voices_by_language[lang].append(voice)
            
            # Display available languages
            console.print(f"[{NORD_CYAN}]Idiomas dispon√≠veis:[/{NORD_CYAN}]")
            languages = sorted(voices_by_language.keys())
            
            for i, lang in enumerate(languages):
                console.print(f"[{NORD_BLUE}]{i+1}.[/{NORD_BLUE}] {lang} ({len(voices_by_language[lang])} vozes)")
            
            # Select language
            lang_idx = int(Prompt.ask("[bold]Selecione o idioma (n√∫mero)", default="1")) - 1
            selected_language = languages[lang_idx]
            
            # Display voices for selected language
            console.print(f"[{NORD_CYAN}]Vozes dispon√≠veis para {selected_language}:[/{NORD_CYAN}]")
            
            voices_in_language = voices_by_language[selected_language]
            for i, voice in enumerate(voices_in_language):
                gender = "Feminina" if "Female" in voice.get("Gender", "") else "Masculina"
                console.print(f"[{NORD_BLUE}]{i+1}.[/{NORD_BLUE}] {voice.get('ShortName')} - {voice.get('DisplayName')} ({gender})")
            
            # Select voice
            voice_idx = int(Prompt.ask("[bold]Selecione a voz (n√∫mero)", default="1")) - 1
            selected_voice = voices_in_language[voice_idx]["ShortName"]
            
            # Create voice settings
            voice_settings = VoiceSettings(
                voice=selected_voice,
                rate=Prompt.ask("[bold]Taxa de fala (ex: +0%, -10%, +20%)", default="+0%"),
                volume=Prompt.ask("[bold]Volume (ex: +0%, -10%, +20%)", default="+0%"),
                pitch=Prompt.ask("[bold]Tom (ex: +0Hz, -10Hz, +20Hz)", default="+0Hz")
            )
            
            # Preview voice
            console.print(f"[{NORD_CYAN}]Gerando preview da voz...[/{NORD_CYAN}]")
            preview_text = "Este √© um exemplo de como esta voz soa. Ser√° utilizada para gerar o √°udio do seu curso."
            preview_path = run_async(tts.preview_voice(voice_settings, preview_text))
            
            if preview_path:
                console.print(f"[{NORD_GREEN}]Preview gerado: {preview_path}[/{NORD_GREEN}]")
                
                # Ask to play preview
                if Confirm.ask("[bold]Deseja reproduzir o preview?", default=True):
                    # Try to play with different commands based on OS
                    try:
                        if sys.platform == "darwin":  # macOS
                            os.system(f"afplay {preview_path}")
                        elif sys.platform == "win32":  # Windows
                            os.system(f"start {preview_path}")
                        else:  # Linux
                            os.system(f"ffplay -nodisp -autoexit {preview_path} 2>/dev/null")
                    except:
                        console.print(f"[{NORD_YELLOW}]N√£o foi poss√≠vel reproduzir o √°udio automaticamente.[/{NORD_YELLOW}]")
            
            # Confirm voice selection
            if not Confirm.ask("[bold]Deseja continuar com esta voz?", default=True):
                console.print(f"[{NORD_YELLOW}]Gera√ß√£o de TTS pulada pelo usu√°rio[/{NORD_YELLOW}]")
            else:
                # Process each markdown file
                tts_results = {"success": [], "failed": []}
                
                with Progress(
                    TextColumn(f"[{NORD_BLUE}]{{task.description}}[/{NORD_BLUE}]"),
                    BarColumn(),
                    TaskProgressColumn(),
                    console=console
                ) as progress:
                    task = progress.add_task(f"[{NORD_CYAN}]Gerando √°udio TTS...[/{NORD_CYAN}]", total=len(processed_files))
                    
                    for markdown_file in processed_files:
                        # Generate output path
                        output_filename = os.path.splitext(os.path.basename(markdown_file))[0] + "_tts.mp3"
                        output_path = os.path.join(course_manager.get_tts_dir(), output_filename)
                        
                        # Generate audio
                        success, result = run_async(tts.generate_audio_from_markdown(
                            markdown_path=markdown_file,
                            output_path=output_path,
                            voice_settings=voice_settings
                        ))
                        
                        if success:
                            tts_results["success"].append((markdown_file, output_path))
                        else:
                            tts_results["failed"].append((markdown_file, result))
                        
                        progress.update(task, advance=1)
                
                if tts_results["success"]:
                    console.print(f"[{NORD_GREEN}]Gera√ß√£o de √°udio TTS conclu√≠da: {len(tts_results['success'])} arquivos gerados[/{NORD_GREEN}]")
                else:
                    console.print(f"[{NORD_RED}]Falha na gera√ß√£o de √°udio TTS[/{NORD_RED}]")
        
        # Step 6: Generate XML podcast feed
        console.print(f"[{NORD_CYAN}]Etapa 6: Gerando XML para podcast...[/{NORD_CYAN}]")
        
        # Ask if user wants to generate XML
        if not Confirm.ask("[bold]Deseja gerar XML para podcast?", default=True):
            console.print(f"[{NORD_YELLOW}]Gera√ß√£o de XML pulada pelo usu√°rio[/{NORD_YELLOW}]")
        else:
            from modules import xml_generator
            
            # Get course information
            course_title = Prompt.ask("[bold]T√≠tulo do podcast", default=course_name)
            course_description = Prompt.ask("[bold]Descri√ß√£o do podcast")
            course_author = Prompt.ask("[bold]Autor do podcast")
            course_language = Prompt.ask("[bold]Idioma do podcast (ex: pt-br)", default="pt-br")
            course_category = Prompt.ask("[bold]Categoria do podcast", default="Education")
            course_image_url = Prompt.ask("[bold]URL da imagem do podcast (opcional)")
            
            # Get audio directory (use TTS if available, otherwise original audio)
            audio_dir = course_manager.get_tts_dir() if os.path.exists(course_manager.get_tts_dir()) else course_manager.get_audio_dir()
            
            # Get audio files
            audio_files = file_manager.get_files_by_extensions(audio_dir, ["mp3"])
            
            if not audio_files:
                console.print(f"[{NORD_YELLOW}]Nenhum arquivo de √°udio encontrado em {audio_dir}[/{NORD_YELLOW}]")
            else:
                # Ask for base URL
                base_url = Prompt.ask("[bold]URL base para os arquivos de √°udio")
                
                # Create XML generator
                generator = xml_generator.PodcastXMLGenerator(
                    title=course_title,
                    description=course_description,
                    author=course_author,
                    language=course_language,
                    category=course_category,
                    image_url=course_image_url if course_image_url else None
                )
                
                # Add episodes
                with Progress(
                    TextColumn(f"[{NORD_BLUE}]{{task.description}}[/{NORD_BLUE}]"),
                    BarColumn(),
                    TaskProgressColumn(),
                    console=console
                ) as progress:
                    task = progress.add_task(f"[{NORD_CYAN}]Adicionando epis√≥dios...[/{NORD_CYAN}]", total=len(audio_files))
                    
                    for audio_file in audio_files:
                        # Get episode title from filename
                        episode_title = os.path.splitext(os.path.basename(audio_file))[0]
                        
                        # Look for corresponding markdown file
                        markdown_path = os.path.join(
                            course_manager.get_processed_dir(),
                            f"{episode_title.replace('_tts', '')}.md"
                        )
                        
                        episode_description = ""
                        if os.path.exists(markdown_path):
                            with open(markdown_path, 'r', encoding='utf-8') as f:
                                # Read first 500 characters as description
                                episode_description = f.read(500) + "..."
                        
                        # Look for corresponding timestamp file
                        timestamp_path = os.path.join(
                            course_manager.get_processed_dir(),
                            f"{episode_title.replace('_tts', '')}.json"
                        )
                        
                        timestamps = None
                        if os.path.exists(timestamp_path):
                            try:
                                import json
                                with open(timestamp_path, 'r', encoding='utf-8') as f:
                                    timestamps = json.load(f)
                            except:
                                pass
                        
                        # Generate episode URL
                        episode_url = f"{base_url.rstrip('/')}/{os.path.basename(audio_file)}"
                        
                        # Add episode
                        generator.add_episode(
                            title=episode_title.replace('_tts', ''),
                            audio_url=episode_url,
                            description=episode_description,
                            timestamps=timestamps
                        )
                        
                        progress.update(task, advance=1)
                
                # Generate XML
                output_path = os.path.join(course_manager.get_xml_dir(), "podcast.xml")
                generator.generate_xml(output_path)
                
                console.print(f"[{NORD_GREEN}]XML gerado com sucesso: {output_path}[/{NORD_GREEN}]")
                
                # Generate timestamps markdown
                timestamps_md_path = os.path.join(course_manager.get_xml_dir(), "timestamps.md")
                generator.generate_timestamps_markdown(timestamps_md_path)
                
                console.print(f"[{NORD_GREEN}]Markdown de timestamps gerado: {timestamps_md_path}[/{NORD_GREEN}]")
        
        # Step 7: Upload to Google Drive
        console.print(f"[{NORD_CYAN}]Etapa 7: Fazendo upload para Google Drive...[/{NORD_CYAN}]")
        
        # Ask if user wants to upload to Drive
        if not Confirm.ask("[bold]Deseja fazer upload para o Google Drive?", default=True):
            console.print(f"[{NORD_YELLOW}]Upload para Google Drive pulado pelo usu√°rio[/{NORD_YELLOW}]")
        else:
            from modules import drive_uploader
            
            # Create Drive uploader
            uploader = drive_uploader.GoogleDriveManager(console=console)
            
            # Authenticate
            if not uploader.authenticate():
                console.print(f"[{NORD_RED}]Falha na autentica√ß√£o com o Google Drive[/{NORD_RED}]")
            else:
                # Create folder
                folder_id = uploader.create_folder(course_name)
                
                if not folder_id:
                    console.print(f"[{NORD_RED}]Falha ao criar pasta no Google Drive[/{NORD_RED}]")
                else:
                    console.print(f"[{NORD_GREEN}]Pasta criada no Google Drive: {course_name} (ID: {folder_id})[/{NORD_GREEN}]")
                    
                    # Get files to upload
                    upload_dirs = [
                        course_manager.get_processed_dir(),
                        course_manager.get_tts_dir() if os.path.exists(course_manager.get_tts_dir()) else course_manager.get_audio_dir(),
                        course_manager.get_xml_dir()
                    ]
                    
                    upload_files = []
                    for upload_dir in upload_dirs:
                        upload_files.extend(file_manager.get_files_by_extensions(
                            upload_dir, ["mp3", "md", "json", "xml"]
                        ))
                    
                    if not upload_files:
                        console.print(f"[{NORD_YELLOW}]Nenhum arquivo encontrado para upload[/{NORD_YELLOW}]")
                    else:
                        # Upload files
                        drive_results = {"success": [], "failed": []}
                        
                        with Progress(
                            TextColumn(f"[{NORD_BLUE}]{{task.description}}[/{NORD_BLUE}]"),
                            BarColumn(),
                            TaskProgressColumn(),
                            console=console
                        ) as progress:
                            task = progress.add_task(f"[{NORD_CYAN}]Fazendo upload de arquivos...[/{NORD_CYAN}]", total=len(upload_files))
                            
                            for file_path in upload_files:
                                # Upload file
                                file_id = uploader.upload_file(
                                    file_path=file_path,
                                    folder_id=folder_id
                                )
                                
                                if file_id:
                                    drive_results["success"].append((file_path, file_id))
                                else:
                                    drive_results["failed"].append(file_path)
                                
                                progress.update(task, advance=1)
                        
                        # Share folder
                        share_link = uploader.share_folder(folder_id)
                        
                        if share_link:
                            console.print(f"[{NORD_GREEN}]Pasta compartilhada publicamente: {share_link}[/{NORD_GREEN}]")
                        
                        # Display results
                        if drive_results["success"]:
                            console.print(f"[{NORD_GREEN}]Upload conclu√≠do com sucesso para {len(drive_results['success'])} arquivos![/{NORD_GREEN}]")
        
        # Step 8: Update GitHub
        console.print(f"[{NORD_CYAN}]Etapa 8: Atualizando GitHub...[/{NORD_CYAN}]")
        
        # Ask if user wants to update GitHub
        if not Confirm.ask("[bold]Deseja atualizar o GitHub?", default=False):
            console.print(f"[{NORD_YELLOW}]Atualiza√ß√£o do GitHub pulada pelo usu√°rio[/{NORD_YELLOW}]")
        else:
            from modules import github_manager_fixed as github_manager
            
            # Get GitHub repository path
            repo_path = Prompt.ask("[bold]Caminho do reposit√≥rio local", default=settings.get_default_github_dir())
            
            # Get GitHub credentials
            github_credentials = credentials.get_github_credentials()
            
            # Create GitHub manager
            manager = github_manager.GitHubManager(
                repo_path=repo_path,
                credentials=github_credentials
            )
            
            # Check if repository is valid
            if not manager.is_valid_repository():
                console.print(f"[{NORD_RED}]O diret√≥rio {repo_path} n√£o √© um reposit√≥rio Git v√°lido[/{NORD_RED}]")
                
                # Ask if user wants to clone a repository
                if Confirm.ask("[bold]Deseja clonar um reposit√≥rio?"):
                    repo_url = Prompt.ask("[bold]URL do reposit√≥rio")
                    
                    # Clone repository
                    if manager.clone_repository(repo_url):
                        console.print(f"[{NORD_GREEN}]Reposit√≥rio clonado com sucesso![/{NORD_GREEN}]")
                    else:
                        console.print(f"[{NORD_RED}]Falha ao clonar reposit√≥rio[/{NORD_RED}]")
            else:
                # Copy files to repository
                github_course_dir = os.path.join(repo_path, course_name)
                
                # Create course directory in repository
                os.makedirs(github_course_dir, exist_ok=True)
                
                # Copy processed files
                import shutil
                
                copy_dirs = [
                    course_manager.get_processed_dir(),
                    course_manager.get_xml_dir()
                ]
                
                for copy_dir in copy_dirs:
                    if os.path.exists(copy_dir):
                        # Create corresponding directory in repository
                        repo_subdir = os.path.join(github_course_dir, os.path.basename(copy_dir))
                        os.makedirs(repo_subdir, exist_ok=True)
                        
                        # Copy files
                        for file in os.listdir(copy_dir):
                            if file.endswith((".md", ".json", ".xml")):
                                shutil.copy2(
                                    os.path.join(copy_dir, file),
                                    os.path.join(repo_subdir, file)
                                )
                
                # Commit and push changes
                if manager.add_all():
                    if manager.commit(f"Add processed files for course: {course_name}"):
                        console.print(f"[{NORD_GREEN}]Altera√ß√µes commitadas com sucesso![/{NORD_GREEN}]")
                        
                        # Push changes
                        if manager.push("main"):
                            console.print(f"[{NORD_GREEN}]Altera√ß√µes enviadas com sucesso![/{NORD_GREEN}]")
                        else:
                            console.print(f"[{NORD_RED}]Falha ao enviar altera√ß√µes[/{NORD_RED}]")
                    else:
                        console.print(f"[{NORD_RED}]Falha ao commitar altera√ß√µes[/{NORD_RED}]")
                else:
                    console.print(f"[{NORD_RED}]Falha ao adicionar arquivos[/{NORD_RED}]")
        
        # Final message
        console.print(f"[{NORD_GREEN}]Processamento completo do curso finalizado com sucesso![/{NORD_GREEN}]")
        
    except Exception as e:
        handle_error("Erro ao processar curso completo", e)

# The configure_settings function is now imported from utils.settings_manager
        settings_panel = Panel(
            Text.from_markup(
                "\n".join([
                    f"[{NORD_BLUE}][1][/{NORD_BLUE}] üîë Gerenciar credenciais de APIs",
                    f"[{NORD_BLUE}][2][/{NORD_BLUE}] üìÅ Configurar diret√≥rios",
                    f"[{NORD_BLUE}][3][/{NORD_BLUE}] üó£Ô∏è Configurar idiomas e vozes TTS",
                    f"[{NORD_BLUE}][4][/{NORD_BLUE}] üìú Gerenciar hist√≥rico de cursos",
                    f"[{NORD_BLUE}][5][/{NORD_BLUE}] üßπ Limpar cache/mem√≥ria",
                    f"[{NORD_BLUE}][0][/{NORD_BLUE}] ‚Üê Voltar"
                ])
            ),
            title="[bold]Configura√ß√µes[/bold]",
            border_style=NORD_CYAN,
            padding=(1, 2)
        )
        console.print(settings_panel)
        
        # Get user choice
        choice = Prompt.ask("[bold]Escolha uma op√ß√£o", choices=["1", "2", "3", "4", "5", "0"], default="0")
        
        if choice == "1":
            # Manage API credentials
            console.print(f"[{NORD_CYAN}]Gerenciando credenciais de APIs[/{NORD_CYAN}]")
            
            # Create credentials panel
            credentials_panel = Panel(
                Text.from_markup(
                    "\n".join([
                        f"[{NORD_BLUE}][1][/{NORD_BLUE}] OpenAI API (Whisper/ChatGPT)",
                        f"[{NORD_BLUE}][2][/{NORD_BLUE}] Anthropic API (Claude)",
                        f"[{NORD_BLUE}][3][/{NORD_BLUE}] Google Drive API",
                        f"[{NORD_BLUE}][4][/{NORD_BLUE}] GitHub API",
                        f"[{NORD_BLUE}][0][/{NORD_BLUE}] ‚Üê Voltar"
                    ])
                ),
                title="[bold]Credenciais de APIs[/bold]",
                border_style=NORD_CYAN,
                padding=(1, 2)
            )
            console.print(credentials_panel)
            
            # Get user choice
            api_choice = Prompt.ask("[bold]Escolha uma API", choices=["1", "2", "3", "4", "0"], default="0")
            
            if api_choice == "0":
                return configure_settings()
            
            # Import credentials module
            from config import credentials
            
            if api_choice == "1":
                # OpenAI API
                api_key = Prompt.ask("[bold]OpenAI API Key", password=True)
                credentials.save_credential("openai_api_key", api_key)
                console.print(f"[{NORD_GREEN}]Credencial da OpenAI API salva com sucesso![/{NORD_GREEN}]")
            
            elif api_choice == "2":
                # Anthropic API
                api_key = Prompt.ask("[bold]Anthropic API Key", password=True)
                credentials.save_credential("anthropic_api_key", api_key)
                console.print(f"[{NORD_GREEN}]Credencial da Anthropic API salva com sucesso![/{NORD_GREEN}]")
            
            elif api_choice == "3":
                # Google Drive API
                console.print(f"[{NORD_CYAN}]Para configurar a Google Drive API:[/{NORD_CYAN}]")
                console.print("1. Acesse o Google Cloud Console e crie um projeto")
                console.print("2. Ative a Google Drive API")
                console.print("3. Crie credenciais OAuth 2.0")
                console.print("4. Baixe o arquivo JSON de credenciais")
                
                credentials_path = Prompt.ask("[bold]Caminho para o arquivo de credenciais JSON")
                
                if os.path.exists(credentials_path):
                    # Copy credentials to data directory
                    import shutil
                    
                    data_dir = os.path.join(os.path.dirname(__file__), "data")
                    os.makedirs(data_dir, exist_ok=True)
                    
                    target_path = os.path.join(data_dir, "google_credentials.json")
                    shutil.copy2(credentials_path, target_path)
                    
                    credentials.save_credential("google_credentials_path", target_path)
                    console.print(f"[{NORD_GREEN}]Credenciais do Google Drive configuradas com sucesso![/{NORD_GREEN}]")
                else:
                    console.print(f"[{NORD_RED}]Arquivo de credenciais n√£o encontrado: {credentials_path}[/{NORD_RED}]")
            
            elif api_choice == "4":
                # GitHub API
                token = Prompt.ask("[bold]GitHub Personal Access Token", password=True)
                username = Prompt.ask("[bold]Nome de usu√°rio do GitHub")
                
                # Save GitHub credentials
                credentials.set_github_credentials(username=username, token=token)
                
                console.print(f"[{NORD_GREEN}]Credenciais do GitHub configuradas com sucesso![/{NORD_GREEN}]")
        
        elif choice == "2":
            # Configure directories
            console.print(f"[{NORD_CYAN}]Configurando diret√≥rios[/{NORD_CYAN}]")
            
            # Get base directory
            base_dir = Prompt.ask("[bold]Diret√≥rio base", default=settings.get_default_base_dir())
            
            # Save setting
            settings.save_setting("base_dir", base_dir)
            
            # Get GitHub directory
            github_dir = Prompt.ask("[bold]Diret√≥rio do GitHub local", default=settings.get_default_github_dir())
            
            # Save setting
            settings.save_setting("github_dir", github_dir)
            
            # Get XML directory
            xml_dir = Prompt.ask("[bold]Diret√≥rio para arquivos XML", default=settings.get_default_xml_dir())
            
            # Save setting
            settings.save_setting("xml_dir", xml_dir)
            
            console.print(f"[{NORD_GREEN}]Diret√≥rios configurados com sucesso![/{NORD_GREEN}]")
        
        elif choice == "3":
            # Configure TTS languages and voices
            console.print(f"[{NORD_CYAN}]Configurando idiomas e vozes TTS[/{NORD_CYAN}]")
            
            # Import TTS generator module
            from modules.tts_generator import EdgeTTSGenerator, VoiceSettings, run_async
            
            # Create TTS generator
            tts = EdgeTTSGenerator(console=console)
            
            # List available voices
            voices = run_async(tts.get_available_voices())
            
            # Group voices by language
            voices_by_language = {}
            for voice in voices:
                lang = voice.get("Locale", "unknown")
                if lang not in voices_by_language:
                    voices_by_language[lang] = []
                voices_by_language[lang].append(voice)
            
            # Display available languages
            console.print(f"[{NORD_CYAN}]Idiomas dispon√≠veis:[/{NORD_CYAN}]")
            languages = sorted(voices_by_language.keys())
            
            for i, lang in enumerate(languages):
                console.print(f"[{NORD_BLUE}]{i+1}.[/{NORD_BLUE}] {lang} ({len(voices_by_language[lang])} vozes)")
            
            # Select language
            lang_idx = int(Prompt.ask("[bold]Selecione o idioma (n√∫mero)", default="1")) - 1
            selected_language = languages[lang_idx]
            
            # Display voices for selected language
            console.print(f"[{NORD_CYAN}]Vozes dispon√≠veis para {selected_language}:[/{NORD_CYAN}]")
            
            voices_in_language = voices_by_language[selected_language]
            for i, voice in enumerate(voices_in_language):
                gender = "Feminina" if "Female" in voice.get("Gender", "") else "Masculina"
                console.print(f"[{NORD_BLUE}]{i+1}.[/{NORD_BLUE}] {voice.get('ShortName')} - {voice.get('DisplayName')} ({gender})")
            
            # Select female voice
            female_idx = int(Prompt.ask("[bold]Selecione a voz feminina padr√£o (n√∫mero)", default="1")) - 1
            female_voice = voices_in_language[female_idx]["ShortName"]
            
            # Select male voice
            male_idx = int(Prompt.ask("[bold]Selecione a voz masculina padr√£o (n√∫mero)", default="2")) - 1
            male_voice = voices_in_language[male_idx]["ShortName"]
            
            # Save settings
            tts_settings = {
                "language": selected_language,
                "female_voice": female_voice,
                "male_voice": male_voice
            }
            
            settings.save_setting("tts", tts_settings)
            
            console.print(f"[{NORD_GREEN}]Configura√ß√µes de TTS salvas com sucesso![/{NORD_GREEN}]")
        
        elif choice == "4":
            # Manage course history
            console.print(f"[{NORD_CYAN}]Gerenciando hist√≥rico de cursos[/{NORD_CYAN}]")
            
            # Load processed courses
            processed_courses = settings.load_processed_courses()
            
            if not processed_courses:
                console.print(f"[{NORD_YELLOW}]Nenhum curso processado encontrado[/{NORD_YELLOW}]")
            else:
                # Display courses
                console.print(f"[{NORD_CYAN}]Cursos processados:[/{NORD_CYAN}]")
                
                table = Table(show_header=True, header_style=NORD_BLUE)
                table.add_column("Nome do Curso")
                table.add_column("Data de Processamento")
                table.add_column("Diret√≥rio")
                
                for course in processed_courses:
                    table.add_row(
                        course.get("name", ""),
                        course.get("date", ""),
                        course.get("directory", "")
                    )
                
                console.print(table)
                
                # Ask if user wants to clear history
                if Confirm.ask("[bold]Deseja limpar o hist√≥rico de cursos?", default=False):
                    settings.clear_processed_courses()
                    console.print(f"[{NORD_GREEN}]Hist√≥rico de cursos limpo com sucesso![/{NORD_GREEN}]")
        
        elif choice == "5":
            # Clear cache/memory
            console.print(f"[{NORD_CYAN}]Limpando cache e mem√≥ria...[/{NORD_CYAN}]")
            
            # Clear temporary files
            import tempfile
            import shutil
            
            temp_dir = tempfile.gettempdir()
            
            # Look for curso_processor temp files
            curso_temp_dirs = [d for d in os.listdir(temp_dir) if d.startswith("tmp") and os.path.isdir(os.path.join(temp_dir, d))]
            
            for d in curso_temp_dirs:
                try:
                    shutil.rmtree(os.path.join(temp_dir, d))
                except:
                    pass
            
            # Clear __pycache__ directories
            for root, dirs, files in os.walk(os.path.dirname(__file__)):
                for d in dirs:
                    if d == "__pycache__":
                        try:
                            shutil.rmtree(os.path.join(root, d))
                        except:
                            pass
            
            console.print(f"[{NORD_GREEN}]Cache e mem√≥ria limpos com sucesso![/{NORD_GREEN}]")
        
        elif choice == "0":
            # Return to main menu
            return
        
    except Exception as e:
        handle_error("Erro nas configura√ß√µes", e)

@app.command()
def main():
    """Main CLI interface"""
    try:
        # Display ASCII art
        display_ascii_art()
        
        while True:
            # Display menu
            display_menu()
            
            # Get user choice
            choice = Prompt.ask("[bold]Escolha uma op√ß√£o", choices=["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10"], default="0")
            
            if choice == "0":
                console.print(f"[{NORD_GREEN}]Saindo... At√© logo![/{NORD_GREEN}]")
                break
            elif choice == "1":
                convert_videos()
            elif choice == "2":
                transcribe_audio()
            elif choice == "3":
                process_with_ai()
            elif choice == "4":
                generate_timestamps()
            elif choice == "5":
                create_tts_audio()
            elif choice == "6":
                generate_xml()
            elif choice == "7":
                upload_to_drive()
            elif choice == "8":
                update_github()
            elif choice == "9":
                process_complete_course()
            elif choice == "10":
                configure_settings()
            
            # Add a separator between operations
            console.print("\n" + "‚îÄ" * console.width + "\n")
    
    except KeyboardInterrupt:
        console.print(f"\n[{NORD_YELLOW}]Opera√ß√£o interrompida pelo usu√°rio[/{NORD_YELLOW}]")
    except Exception as e:
        handle_error("Erro na aplica√ß√£o", e)

if __name__ == "__main__":
    app()